# U-Bootドキュメント: 環境変数

[オリジナル](https://u-boot.readthedocs.io/en/latest/usage/environment.html)

U-Bootは環境変数を使ったユーザ構成をサポートしています。ユーザ構成は
フラッシュメモリなどの永続ストレージに保存することで永続化することが
できます。

環境変数は"env set"（別名 "setenv"）で設定し、"env print"（別名
"printenv"）で表示し、"env save"（別名 "saveenv"）で永続ストレージに
保存します。"env set"を値なしで使用すると環境から変数を削除することが
できます。環境を保存しない限り、メモリ上に存在するコピーで作業して
いることになります。環境を含むFlash領域が誤って消去された場合は
デフォルトの環境が提供されます。

詳細は[envコマンド](https://u-boot.readthedocs.io/en/latest/usage/cmd/env.html)を参照してください。

一部の構成は環境変数により制御されます。したがって、変数を設定する
ことでU-Bootの動作を調整することができます（自動ブートの遅延時間や
tftpからの自動ロードなど）。

## テキストベースの環境

ボードのデフォルト環境はシンプルなテキスト形式 *.env* 環境ファイルを
使って作成されます。このファイルのベースファイル名は
*CONFIG_ENV_SOURCE_FILE* により定義されます。これが空の場合は
*CONFIG_SYS_BOARD* が使用されます。

このファイルはボードディレクトリにあり、拡張子が`.env`でなければ
なりません。したがって、あるボードベンダがあると仮定するとその
ファイル名は次のようになります。

```c
board/<vendor>/<board>/<CONFIG_ENV_SOURCE_FILE>.env
```

あるいは、次のとおり。

```c
board/<vendor>/<board>/<CONFIG_SYS_BOARD>.env
```

これはプレーンテキストファイルであり、環境変数を *var=value* の
形式で入力することができます。空行や複数行の変数もサポートされて
います。変換スクリプトはカラム1が文字列で始まり、直後に等号がある
行を探します。`=`の前に空白を置いてはいけません。スクリプトを
インデントして、行頭に'var='だけが表示されるようにするとよいでしょう。

変数にテキストを追加するには *var+=value* を使用します。この
テキストはmake処理中に変数にマージされ、U-Bootでは1つの値として
利用できるようになります。変数には '+' 文字を含めることができますが
万が一 '+' で終わる変数名を付けたい場合は、既存の変数に追加するのでは
なく、新しい変数に代入することをスクリプトが認識できるように、次の
用に  '+' の前にバックスラッシュを付けてください。

```c
maximum\+=value
```

このファイルにはCスタイルのコメントを含めることができます。空白行や
複数行の変数もサポートされています。また、通常のCプリプロセッサ
ディレクティブやボードconfigのCONFIG定義を使用することもできます。

たとえば、snapper9260用に次のような環境テキストを含む
*board/bluewater/snapper9260.env* というテキストファイルを作成する
ことになるでしょう。

**例**:

```c
stdout=serial
#ifdef CONFIG_VIDEO
stdout+=,vidconsole
#endif
bootcmd=
    /* U-Boot script for booting */

    if [ -z ${tftpserverip} ]; then
        echo "Use 'setenv tftpserverip a.b.c.d' to set IP address."
    fi

    usb start; setenv autoload n; bootp;
    tftpboot ${tftpserverip}:
    bootm
failed=
    /* Print a message when boot fails */
    echo CONFIG_SYS_BOARD boot failed - please check your image
    echo Load address is CONFIG_SYS_LOAD_ADDR
```

ボードグループに共通する設定は *#includ* を使用して、環境設定を含む
*include/env* ディレクトリにある共通ファイルを取り込むことができます。

たとえば次のように。

```c
#include <env/ti/mmc.env>
```

CONFIG_ENV_SOURCE_FILEが空で、デフォルトのファイル名が存在しない場合は
古いスタイルのC環境が使用されます。以下を参照してください。

## 古いスタイルのC環境

従来と同様、デフォルトの環境を *include/env_default.h* で作成し、
様々なCONFIG定義で拡張することができます。詳細はこのファイルを
参照してください。特に、ボードファイルで *CFG_EXTRA_ENV_SETTINGS* を
定義して環境変数を追加することができます。

ボードメンテナにはメンテが簡単なのでテキストベースの環境に移行する
ことを推奨します。distro-boardスクリプトは依然として古いスタイルの
環境を必要とするので[U-Bootの標準的なブート](https://u-boot.readthedocs.io/en/latest/develop/bootstd.html)を
使ってください。

## 環境変数一覧

デバイス構成オプションの中には環境変数を使って設定することができる
ものがあります。多くの場合、デフォルトの環境変数の値は CONFIG
オプションに由来します。これについては *include/env_default.h* を
参照してください。

これは完全なリストではない可能性が高いです。

<dl>
<dt>
<h3>autostart</h3>
</dt>
<dd>
"yes"を設定すると（実際には`1`, `y`, `Y`,` t`, `T`で始まる任意の
文字列）以下のコマンドでロードされるイメージが内部的に`bootm`
コマンドを起動することで自動的に起動されます。

- **bootelf** - メモリ内のELFイメージから起動します
- **bootp** - BOOTP/TFTPプロトコルを使ってネットワーク経由で
  イメージを起動します
- **dhcp** - DHCP/TFTPプロトコルを使ってネットワーク経由で
  イメージを起動します
- **diskboot** - ide ¥デバイスから起動します
- **nboot** - NANDデバイスから起動します
- **nfs** - NFS ロトコルを使ってネットワーク経由でイメージを起動します
- **rarpboot** - RARP/TFTPプロトコルを使ってネットワーク経由で
  イメージを起動します
- **scsiboot** - SCSIデバイスから起動します
- **tftpboot** - TFTPプロトコルを使ってネットワーク経由でイメージを
  起動します
- **usbboot** - USBデバイスから起動します

環境変数`autostart`に1、y、Y、t、Tで始まる値が設定されていない場合、
"bootm"コマンドに渡されたイメージはロードアドレスにコピーされますが
（最終的には解凍されます）、起動は**されません**。これは任意の
データをロードして解凍するためにに使用することができます。
</dd>

<dt><h3>baudrate</h3></dt>
<dd>

UARTのボーレートを設定するために使用します。デフォルトは
CONFIG_BAUDRATE（このconfigのデフォルト値は115200）です。

<dt><h3>bootdelay</h3></dt>
<dd>
bootcmdを自動的に実行するのを遅延させます。この間にユーザはシェルに
入るか否か選択できます（`CONFIG_AUTOBOOT_MENU_SHOW=y`の場合は
ブートメニューが表示されます）。

* 0: 遅延なしで自動起動するが、キー入力で停止できます
* -1: 自動起動を無効にします
* -2: 遅延なしで自動起動し、異常終了をチェックしません

デフォルト値は`CONFIG_BOOTDELAY`で定義されてます。`CONFIG_OF_CONTROL=y`
の場合、'bootdelay'の値はデバイスツリーの`/config/bootdelay`の値で
上書きされます。
</dd>

<dt><h3>bootcmd</h3></dt>
<dd>
起動遅延中にユーザがシェルに入らなかった場合に実行されるコマンドです。
</dd>

<dt><h3>bootargs</h3></dt>
<dd>
オペレーティングシステムやバイナリイメージを起動する際に渡される
コマンドライン引数です。
</dd>

<dt><h3>bootfile</h3></dt>
<dd>
TFTPでロードするイメージの名前です。
</dd>

<dt><h3>bootm_low</h3></dt>
<dd>
bootmコマンド内でイメージ処理に使用可能なメモリ範囲を制限することが
できます。この変数は16進数で指定し、bootmコマンドで使用できる最小
アドレスを定義します。"bootm_size"環境変数も参照してください。
"bootm_low"で定義されたアドレスはLinuxカーネルの初期メモリマッピングの
ベースにもなります。`CFG_SYS_BOOTMAPSZ`と`bootm_mapsize`の説明を
参照してください。
</dd>

<dt><h3>bootm_mapsize</h3></dt>
<dd>
Linuxカーネルの初期メモリマッピングのサイズです。この変数は16進数で
指定し、初期ブート時にLinuxカーネルがアクセス可能な基底アドレス
bootm_lowから始まるメモリ領域のサイズを定義します。未設定の場合は
定義されていれば`CFG_SYS_BOOTMAPSZ`がデフォルト値が使用されます。
定義されていなければ`bootm_size`が使用されます。
</dd>

<dt><h3>bootm_size</h3></dt>
<dd>
bootmコマンド内でイメージ処理に使用可能なメモリ範囲を制限することが
できます。この変数は16進数で指定し、bootmコマンドで使用できる領域の
サイズを定義します。"bootm_low"環境変数も参照してください。
</dd>

<dt><h3>bootstopkeysha256`, `bootdelaykey`, `bootstopkey</h3></dt>
<dd>
`README.autoboot`を参照してください。
</dd>

<dt><h3>updatefile</h3></dt>
<dd>
自動ソフトウェアアップデート機能で使用されるTFTPサーバー上の
ソフトウェアアップデートファイルの場所です。詳細は`doc/README.update`
を参照してください。
</dd>

<dt><h3>autoload</h3></dt>
<dd>

"no"（'n'で始まる任意の文字列）を設定すると、"bootp"と"dhcp"は
BOOTPサーバから構成の検索を行うだけでイメージのロードを試みなく
なります。

<dt><h3>fdt_high</h3></dt>
<dd>
この変数を設定するとブート時にフラット化されたデバイスツリーが
コピーされる最大アドレスを制限します。たとえば、物理アドレス
0x1000_0000に1GBのメモリがあるシステムで、Linuxカーネルが最初の
704MBしか低位メモリとして認識しない場合、fdt_highを0x3C00_0000に
設定して、デバイスツリーブロブを704MBの低位メモリの最大アドレスに
コピーし、Linuxカーネルがブート処理中にアクセスできるようにする
必要があるでしょう。

この変数に特別な値`0xffff_ffff`（32ビットマシン）、または、
0xffff_ffff_ffff（64ビットマシン）を設定するとブート時にfdtが
コピーされなくなります。これが機能するためには、このアドレスが
書き込み可能なメモリー内にあり、その末尾にu-bootが必要な情報を
追加するための十分なパディングがあり、そのメモリがカーネルから
アクセス可能である必要があります。しかし、この使い方はまったく
推奨されません。なぜなら、同時にU-Bootがデバイスツリーの開始
アドレスを適切にアラインメントすることも止め、アラインメントが
取れていないツリーはOSに障害を引き起こすからです。
</dd>

<dt><h3>fdtcontroladdr</h3></dt>
<dd>
この変数を設定すると、CONFIG_OF_CONTROLが定義されているときに
U-Bootが使用するcontrol flattenedデバイスツリーのアドレスに
なります。
</dd>

<dt><h3>initrd_high</h3></dt>
<dd>
initrdイメージの位置を制限します。この変数が設定されていない場合、
initrdイメージはRAM上の可能な限り最高位のアドレスにコピーされます。
これはinitrdのサイズを最大にできるので通常は望ましいものです。
何らかの理由でinitrdイメージをCFG_SYS_BOOTMAPSZの制限値以下にロード
したい場合はこの環境変数の値に"no", "off", "0"に設定します。あるいは、
使用する最大上限アドレスを設定することもできます（この場合も、
U-BootはU-Bootのスタックとデータを上書きしないかチェックします）。

たとえば、16MBのRAMを持つシステムでLinuxで使用するために4MBを確保
したい場合は"bootargs"変数の値に"mem=12M"を追加することで実現できます。
ただし、initrdイメージが最初の12MBに配置されていることも確認する
必要があります。これは次の設定で行なえます。

```c
setenv initrd_high 00c00000
```

initrd_highを0xffff_ffff（32ビットマシン）または、0xffff_ffff_ffff
（64ビットマシン）に設定すると、これはフラッシュメモリのアドレスを
含むすべてのアドレスがLinuxカーネルにとって合法であることをU-Bootに
示します。この場合、U-Bootはramdiskを**コピーしません**。これは
システムのブート時間を短縮するのに便利ですが、この機能がLinux
カーネルでサポートされている必要があります。ただし、この使用法では
LinuxカーネルのBSSなど、イメージの他の部分と重複しないことをユーザが
確認する必要があります。デフォルトでは有効にせず、デプロイメントを
最適化する場合にのみ有効にしてください。
</dd>

<dt><h3>ipaddr</h3></dt>
<dd>
IPアドレスです。tftpbootコマンで必要になります。
</dd>

<dt><h3>loadaddr</h3></dt>
<dd>
"bootp"、"rarpboot"、"tftpboot"、"loadb"、"diskboot"などのコマンドの
デフォルトのロードアドレスです。最適なデフォルト値はアーキテクチャに
より異なることに注意してください。たとえば、32ビットARMの場合、Linux
カーネルのzImageには自己解凍機能があるため、メモリの開始位置から
何らかのオフセットが使用されます。そのため、そのような場所には
近づかないのがベストです。
</dd>

<dt><h3>loads_echo</h3></dt>
<dd>
CONFIG_LOADS_ECHOを参照してください。
</dd>

<dt><h3>serverip</h3></dt>
<dd>
TFTPサーバのIPアドレスです。tftpbootコマンドで必要になります。
</dd>

<dt><h3>bootretry</h3></dt>
<dd>
CONFIG_BOOT_RETRY_TIMEを参照してください。
</dd>

<dt><h3>bootdelaykey</h3></dt>
<dd>
CONFIG_AUTOBOOT_DELAY_STRを参照してください。
</dd>

<dt><h3>bootstopkey</h3></dt>
<dd>
CONFIG_AUTOBOOT_STOP_STRを参照してください。
</dd>

<dt><h3>ethprime</h3></dt>
<dd>
最初にどのネットワークインタフェースを使用するかを制御します。
</dd>

<dt><h3>ethact</h3></dt>
<dd>
どのインタフェースが現在アクティブであるかを制御します。たとえば、
次のようにします。

```c
=> setenv ethact FEC
=> ping 192.168.0.1     # traffic sent on FEC
=> setenv ethact SCC
=> ping 10.0.0.1        # traffic sent on SCC
```

</dd>

<dt><h3>ethrotate</h3></dt>
<dd>
"no"を設定すると、U-Bootは利用可能なすべてのネットワークインタ
フェイスの使用を試みることなく、現在選択されているインタフェイスに
留まります。未設定、または、"no"以外の値が設定されている場合、
U-Bootは利用可能なすべてのネットワークインタフェイスの使用を
試みます。
</dd>

<dt><h3>netretry</h3></dt>
<dd>
"no"を設定すると、各ネットワーク操作は再試行せずに成功か、失敗かの
いずれかになります。"once"を設定すると、利用可能なすべてのネット
ワークインタフェースを一度だけ試して成功しなかった場合にネットワーク
操作が失敗します。再試行を自分で制御するスクリプトで役に立ちます。
</dd>

<dt><h3>silent_linux</h3></dt>
<dd>
設定すると、Linuxはコマンドラインに'console='を追加することで
起動時に何も表示しないように指示されます。"yes"を指定した場合も
表示しません。"no"を指定した場合は表示を行います。未設定の場合は
U-Bootコンソールが表示をしない設定であれば表示しません。
</dd>

<dt><h3>tftpsrcp</h3></dt>
<dd>
設定すると、その値はTFTPのUDP発信元ポート番号として使用されます。
</dd>

<dt><h3>tftpdstp</h3></dt>
<dd>
設定すると、その値はTFTPのUDP宛て先ポート番号のデフォルトポート番号
69の代わりとして使用されます。
</dd>

<dt><h3>tftpblocksize</h3></dt>
<dd>
TFTP転送で使用するブロックサイズです。設定しないと、TFTPサーバの
デフォルトブロックサイズを使用します。
</dd>

<dt><h3>tftptimeout</h3></dt>
<dd>
TFTPパケットの再送タイムアウト（ミリ秒単位で最小値は1000 = 1秒）です。
パケットが失われたとみなされ、再送が必要となる時間を定義します。
デフォルトは5000 = 5秒です。この値を小さくするとパケット損失率が高い
ネットワークや信頼性の低いTFTPサーバーでダウンロードをより速く成功
させる場合があります。
</dd>

<dt><h3>tftptimeoutcountmax</h3></dt>
<dd>
TFTPタイムアウトの最大回数（単位なし、最小値 = 0）です。1回のファイル
転送中に何回タイムアウトが発生するとその転送が中止されるかを定義
します。デフォルトは10です。"0"は「タイムアウトを許可しない」ことを
意味します。この値を大きくすると、パケット損失率が高い場合や信頼性の
低いTFTPサーバやクライアントハードウェアでダウンロードが成功しやすく
場合があります。
</dd>

<dt><h3>tftpwindowsize</h3></dt>
<dd>
設定されていると、その値はRFC 7440で規定されているTFTPのウィンドウ
サイズとして使用されます。これはサーバにackを送信する前に受信できる
ブロック数を意味します。
</dd>

<dt><h3>vlan</h3></dt>
<dd>
4095未満の値を設定すると、イーサネット上のトラフィックが802.1q VLAN
タグ付きフレームでカプセル化されて受信されます。

注: U-Bootでは使用されていないようです。*README.VLAN* を参照して
ください。
</dd>

<dt><h3>bootpretryperiod</h3></dt>
<dd>
BOOTP/DHCPが再試行を送信する期間です。ミリ秒単位の符号なし値で
設定します。設定されていない場合、この期間はデフォルト値 (28000)か
（定義されていれば）CONFIG_NET_RETRY_COUNTに基づく値のいずれかに
なります。この値はCONFIG_NET_RETRY_COUNTに基づく値よりも優先されます。
</dd>

<dt><h3>memmatches</h3></dt>
<dd>
最新の'ms'コマンドでマッチした数（16進数）です。
</dd>

<dt><h3>memaddr</h3></dt>
<dd>
'ms'コマンドでマッチした最新のアドレス（16進数）です。マッチした
アドレスがなかった場合は0です。
</dd>

<dt><h3>mempos</h3></dt>
<dd>
'ms'コマンドで見つかった最新のマッチのインデックス位置です。検索
サイズ（.b, .w, .l）のユニット数で表されます。
</dd>

<dt><h3>zbootbase</h3></dt>
<dd>
（x86のみ）bzImageの'setup'ブロックの基底アドレスです。
</dd>

<dt><h3>zbootaddr</h3></dt>
<dd>
（x86のみ）ロードされたbzImageのアドレス。通常は、BZIMAGE_LOAD_ADDRで
0x10_0000です。
</dd>
</dl>

## イメージのロケーション

以下のイメージロケーション変数にはブートに使用されるイメージの
ロケーションが含まれます。”イメージ"列はイメージの役割を示して
おり環境変数名ではありません。その他の列は環境変数名です。"ファイル名"
はTFTPサーバ上のファイル名、"RAMアドレス"はイメージがロードされる
RAM上のロケーション、"Flashロケーション"はNORフラッシュ上のイメージの
アドレス、または、NANDフラッシュ上のオフセットです。

*注意* - これらの変数はすべてのボードで定義されている必要は
ありません。現在、これらの目的で他の変数を使用しているボードも
ありますし、他の目的でこれらの変数を使用しているボードもあります。

また、これらの変数のほとんどは、他の変数定義で使用される変数名と
して一般に使用される名前であり、U-Bootコードのどこにもハードコード
されていないことに注意してください。

| イメージ | ファイル名 | RAMアドレス | FLASHロケーション |
|:---------|:-----------|:------------|:----------------- |
| Linuxカーネル | bootfile | kernel_addr_r | kernel_addr |
| デバイスツリーblob | fdtfile | fdt_addr_r | fdt_addr |
| ramdisk | ramdiskfile | ramdisk_addr_r | ramdisk_addr |

*kernel_addr_r*, *fdt_addr_r*, *ramdisk_addr_r*のRAMアドレスを
設定する際にはいくつかの制約に注意する必要があります。制約の1つは
ペイロード要件です。たとえば、デバイスツリーは仕様が要求している
ように、8バイトアライメントされたアドレスにロードする必要があります
（MUST）。同様に、オペレーティングシステムはペイロードをメモリ空間の
どこに置けるかについての制限を定義することができます。これは
たとえば、Linuxでは[Booting ARM Linux](https://www.kernel.org/doc/html/latest/arm/booting.html)と
[Booting AArch64 Linux](https://www.kernel.org/doc/html/latest/arm64/booting.html)で
文書化されています。最後に実際上の制約があります。ユーザが使用する
ペイロードのサイズは分かりませんが、各ペイロードはオーバーラップ
してはいけません。他のペイロードを破損するからです。ペイロードが
OSのBSS領域に入ってしまった場合にも同様の問題が起こりえます。
このような理由から、デフォルト値がブートに失敗する可能性が低く、
十分に説明できるもので、ブート時間を最適化したり、より小さなメモリ
構成に調整できるようにする必要があります。

アーキテクチャが異なれば制約も異なります。上位互換性を確保する
ためには文書化された要件に従うことが重要です。以下に示すのは
様々なケースで妥当なデフォルト値を提供する方法を強調するための例を
示しています。

### Texas Instrument OMAP2PLUS (ARMv7)の例

これらのプロセッサファミリーは32ビットのARMv7コアを使用して
います。Linuxのブートは最も一般的なペイロードであるので、Linuxが
提供するブートのための文書化された要件にも留意することになります。
以下の値はその他多くのオペレーティングシステム（またはそのローダ）の
ブートにも問題ないことが知られています。この例では以下の変数と値を
定義します。

```bash
loadaddr=0x82000000           # 0x8000_0000 + 32 MiB
kernel_addr_r=${loadaddr}     #
fdt_addr_r=0x88000000         # 0x8000_0000 + 128 MiB
ramdisk_addr_r=0x88080000     # 0x8000_0000 + 128 MiB + 512 KB
bootm_size=0x10000000         # 256 MiB
```

最初に注意すべきことはDRAMは0x8000_0000から始まるということです。
デフォルトのロードアドレスとしてメモリの先頭から32MiBのバッファを
設定し、kernel_addr_rをそれに設定しています。これは、LinuxのzImage
解凍器が自身をリロケーションしなくてもすむようにするためです。
また、カーネルはメモリの最初の128MiB以内になければなりません。
次の値はfdt_addr_rをメモリの先頭から128MiBのオフセットに設定して
います。この位置はカーネルのドキュメントで推奨されており、他の
アーキテクチャ上の制約を考えると、カーネル自身によって上書きされる
可能性は極めて低いからです。次に、ramdiskをメモリに配置する前に
デバイスツリーのサイズを最大512KiBまで許容しています。そして、
U-Bootが適切なアライメントを確保するために必要に応じて再配置できる
ように、すべてがメモリの最初の256MiB内にあるべきであるとしています。
ここで256MiBを値として選んだのは、このファミリにこれより少ない
メモリを搭載したプラットフォームはほとんどないことを知っている
からです。768MiBまで大きくしても、すべてがカーネルに見えるように
することは可能ですが、ここでも最も安全な仮定を採用しています。

## 自動更新変数

以下の環境変数はネットワークブートコマンド（"bootp "と"rarpboot"）で
使用され、ブートサーバから提供される情報に応じて自動的に更新することが
できます。

| 変数 | 注記 |
|:-----|:-----|
| bootfile | 上を参照 |
| dnsip | ドメインネームサーバのIPアドレス |
| dnsip2 | セカンダリDNSサーバのIPアドレス |
| gatewayip | ゲートウェイ（ルータ）のIPアドレス |
| hostname | 宛先ホスト名 |
| ipaddr | 上を参照 |
| netmask | サブネットマスク |
| rootpath | NFSサーバ上のrootファイルシステムのパス名 |
| serverip 上を参照 |

## 特別な環境変数

特別な環境変数が2つ存在します。

<dl>
<dt><h3>serial#</h3></dt>
<dd>
type文字列やシリアル番号などのハードウェア識別情報を含みます。
</dd>

<dt><h3>ethaddr</h3></dt>
<dd>
Ethernetアドレスです。`CONFIG_REGEX=y`の場合、eth*addr（ここで*は
整数）も存在します。
</dd>
</dl>

これらの変数は一度だけ設定できます（通常はボードの製造時）。
U-Bootはボード構成でCONFIG_ENV_OVERWRITEが有効になっていない限り、
一度設定されたこれらの変数の削除や上書きを拒否します。

さらに

<dl>
<dt><h3>var</h3></dt>
<dd>
"version"コマンドで表示されるU-Bootのバージョン文字列を含みます。
この変数はReadonlyです（CONFIG_VERSION_VARIABLEを参照）。
</dd>
</dl>

構成パラメータの変更が有効になるのは次回のブート後であることに
注意してください（そう、これはWindowsと同じです）。

## 外部環境ファイル

*CONFIG_USE_DEFAULT_ENV_FILE* オプションは、U-Bootの環境生成を
バイパスする方法を提供します。有効にすると、*CONFIG_DEFAULT_ENV_FILE*
環境に変換されるファイル名を提供します。これは *env_default.h* に
ある標準的な環境変数を完全にバイパスします。

フォーマットは`mkenvimage`ツールが受け付けるものと同じで、
`key=value`のペアを含む行で構成されます。空白行や#で始まる行は
無視されます。

将来的にはこの機能はテキストベースの環境と統一され、*env_default.h*
の内容はテキストファイルに移されるかもしれません。

## 実装

内部の開発詳細は[環境実装](https://u-boot.readthedocs.io/en/latest/develop/environment.html)を参照してください。
